<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Driving</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
    <script src="https://cdn.jsdelivr.net/npm/axios@1.1.2/dist/axios.min.js"></script>
    <script type="module">
		import * as THREE from "../build/three.module.js";
		import { OrbitControls } from '../examples/jsm/controls/OrbitControls.js';
        import {GUI} from '../examples/jsm/libs/lil-gui.module.min.js'
        import  StreamWorker from './worker.js'

        let scene, camera, renderer, controls;
        let body, batchSize = 4, lastFrame = 1;
        let frameLength = 70;
        let frame = [];
        let cloudPointMesh, circles = [], boxs = [], trackletsLine = [], vehicleLine = [];

        const YZMAT = new THREE.Matrix4().set(1, 0, 0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0, 0, 1);
        const WEBGL_COMPONENT_TYPES = {
            5120: Int8Array,
            5121: Uint8Array,
            5122: Int16Array,
            5123: Uint16Array,
            5125: Uint32Array,
            5126: Float32Array
        };

        const BINARY_EXTENSION_HEADER_MAGIC = 'glTF';

        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 100000)
        camera.position.z = 30;
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        const light = new THREE.AmbientLight( 0x404040 ); // soft white light
		scene.add( light );

        const geometry = new THREE.BoxGeometry( 10, 10, 10 );
        const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        const cube = new THREE.Mesh( geometry, material );
        // scene.add( cube );

        let mianGroup  = new THREE.Group();
        mianGroup.applyMatrix4(YZMAT)
        scene.add(mianGroup);
        let option = {
            frame: 0,
        }

        let gui = new GUI();

        gui.add( option, 'frame', 0, 68,1 ).onChange( function () {
            if(frame[option.frame]){
                loadFrameData(frame[option.frame])
            }
        });

        let worker = new StreamWorker((event) =>{
            frame[event.index] = event.data
            console.log(event.data,event.index )
        });

        function loadFrameData(data){
            loadCloudPoint(data.cloudPoint)
            loadCircles(data.circles)
            loadBoxs(data.mesh)
            loadTrackletsLine(data.trackletsLine)
            loadVehicleLine(data.vehicleLine)
        }

        function loadCloudPoint(cloudPoint){
             if(!cloudPointMesh){
                cloudPoint.forEach(item =>{
                    let pointGeometry = new THREE.BufferGeometry();
                    pointGeometry.setAttribute('position', new THREE.BufferAttribute(item.pointsBuffer, 3));
                    pointGeometry.setAttribute( 'color', new THREE.Float32BufferAttribute(item.colorsBuffer, 4 ));
                    cloudPointMesh = new THREE.Points(pointGeometry, new THREE.PointsMaterial({size: 0.1, vertexColors: true}));
                    mianGroup.add(cloudPointMesh);
                })
            } else {
                cloudPoint.forEach(item =>{
                    cloudPointMesh.geometry.setAttribute('position', new THREE.BufferAttribute(item.pointsBuffer, 3));
                    cloudPointMesh.geometry.setAttribute( 'color', new THREE.Float32BufferAttribute(item.colorsBuffer, 4 ));
                })
            }
           
        }

        function loadCircles(data){
            circles.forEach(item => {
                item.geometry.dispose();
                item.material.dispose();
                item.removeFromParent();
            })
            circles = [];

            data.forEach(item =>{
                let geometry = new THREE.CircleGeometry( 0.2, 32 );
                let material = new THREE.MeshBasicMaterial( { color: 0xFF8C00 } );
                let circle = new THREE.Mesh( geometry, material );
                circle.position.set(item.center[0], item.center[1], item.center[2]);
                mianGroup.add( circle );
                circles.push(circle)
            })
        }

        function loadBoxs(data){
            boxs.forEach(item => {
                item.box.geometry.dispose();
                item.box.material.dispose();
                item.box.removeFromParent();
                item.line.geometry.dispose();
                item.line.material.dispose();
                item.line.removeFromParent();
            })
            boxs = [];
            data.forEach(item =>{
                let positionAttribute = new THREE.BufferAttribute(new Float32Array(item.vertices), 3);
                let BoxGeometry = new THREE.BufferGeometry();
                BoxGeometry.setAttribute('position', positionAttribute)
                BoxGeometry.setIndex(item.meshIndices);
                let boxMaterial = new THREE.MeshBasicMaterial( { color: 0x008C00, transparent: true, opacity: 0.5 } );
                let box = new THREE.Mesh( BoxGeometry, boxMaterial );
                mianGroup.add( box );

                let lineGeometry = new THREE.BufferGeometry();
                lineGeometry.setAttribute('position', positionAttribute)
                lineGeometry.setIndex(item.lineIndices);
                let lineMaterial = new THREE.LineBasicMaterial( { color: 0x008C00 } );
                let line = new THREE.LineSegments( lineGeometry, lineMaterial );
                mianGroup.add( line );
                boxs.push({
                    box: box,
                    line: line
                })
            })
        }

        function loadTrackletsLine(data){
            trackletsLine.forEach(item => {
                item.geometry.dispose();
                item.material.dispose();
                item.removeFromParent();
            })
            trackletsLine = [];
            data.forEach(item =>{
                if(item.vertices){
                    let positionAttribute = new THREE.BufferAttribute(new Float32Array(item.vertices), 3);
                    let pathGeometry = new THREE.BufferGeometry();
                    pathGeometry.setAttribute('position', positionAttribute)
                    pathGeometry.setIndex(item.indices);
                    let pathMaterial = new THREE.MeshBasicMaterial( { color: 0x008C00 } );
                    let path = new THREE.Mesh( pathGeometry, pathMaterial );
                    mianGroup.add( path );
                    trackletsLine.push(path);
                }

            })

        }

        function loadVehicleLine(data){
            vehicleLine.forEach(item => {
                item.geometry.dispose();
                item.material.dispose();
                item.removeFromParent();
            })
            vehicleLine = [];
            data.forEach(item =>{
                let positionAttribute = new THREE.BufferAttribute(new Float32Array(item.vertices), 3);
                let pathGeometry = new THREE.BufferGeometry();
                pathGeometry.setAttribute('position', positionAttribute)
                pathGeometry.setIndex(item.indices);
                let pathMaterial = new THREE.MeshBasicMaterial( { color: 0x008C00 } );
                let path = new THREE.Mesh( pathGeometry, pathMaterial );
                mianGroup.add( path );
                vehicleLine.push(path);
            })

        }

        function loadStart(){
            for(let i = 1; i <= batchSize && i <= frameLength; i++ ){
                loadNextFrame();
            }
        }


        function loadNextFrame(){
            lastFrame++;
            let url = './public/'+ lastFrame +  '-frame.glb';

            if(lastFrame > frameLength) return;
            let index = lastFrame
            axios.get(url, {
                responseType: "arraybuffer"
            }).then((res) =>{
                worker.work(res.data, index - 2)
                loadNextFrame()
            })
        }

        function getMagicString(dataView) {
            var byteOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            return "".concat(String.fromCharCode(dataView.getUint8(byteOffset + 0))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 1))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 2))).concat(String.fromCharCode(dataView.getUint8(byteOffset + 3)));
        }


        function animate() {
            renderer.render( scene, camera );
            requestAnimationFrame(animate);
        }
        animate()

        loadStart()
    </script>
</body>

</html>